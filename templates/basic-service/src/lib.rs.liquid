//! {{ description }}
//!
//! This is a JAM (Join-Accumulate Machine) service for Polkadot.
//! JAM services implement two main entry points:
//! - `refine`: Stateless computation (up to 6 seconds PVM execution)
//! - `accumulate`: Stateful integration into chain state (~10ms)

#![no_std]
#![no_main]

extern crate alloc;

use alloc::vec::Vec;
use jam_pvm_common::{
    declare_service,
    Service,
    accumulate::{set_storage, get_storage},
    jam_types::*,
};

declare_service!({{ project_name | pascal_case }}Service);

/// {{ project_name | pascal_case }} JAM Service
///
/// {{ description }}
struct {{ project_name | pascal_case }}Service;

impl Service for {{ project_name | pascal_case }}Service {
    /// Refine: Stateless computation that transforms work items into work results.
    ///
    /// This runs off-chain with up to 6 seconds of PVM execution time.
    /// - Accepts work items as input (up to 15 MB per time slot)
    /// - Produces work results as output (max 90 KB)
    /// - Can perform preimage lookups via hash
    /// - Runs in a metered PVM environment
    fn refine(
        _core_index: CoreIndex,
        _item_index: usize,
        _service_id: ServiceId,
        payload: WorkPayload,
        _package_hash: WorkPackageHash,
    ) -> WorkOutput {
        // Get the input data from the work payload
        let data = payload.take();

        // TODO: Implement your stateless refinement logic here
        // This example just echoes back the input with a success prefix
        let mut result = Vec::with_capacity(data.len() + 1);
        result.push(0x01); // Success marker
        result.extend_from_slice(&data);

        result.into()
    }

    /// Accumulate: Stateful function that integrates work results into chain state.
    ///
    /// This runs on-chain with approximately 10ms execution time.
    /// - Read storage from any service
    /// - Write to its own key-value store
    /// - Transfer funds between services
    /// - Create new services
    /// - Upgrade its own code
    fn accumulate(
        _slot: Slot,
        _service_id: ServiceId,
        item_count: usize,
    ) -> Option<Hash> {
        // Update the count of processed items
        let current_count = get_storage(b"count")
            .and_then(|v| v.first().copied())
            .unwrap_or(0);
        let new_count = current_count.saturating_add(item_count as u8);
        set_storage(b"count", &[new_count]).ok();

        // TODO: Implement your stateful accumulation logic here
        // Read work results and update service state

        None
    }
}
